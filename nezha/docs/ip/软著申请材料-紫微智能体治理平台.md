# 紫微智能体治理基础设施平台 V1.0 软件著作权申请材料

**申请日期**：2026年2月  
**申请人**：[待补充]  
**软件全称**：紫微智能体治理基础设施平台  
**软件简称**：紫微平台  
**版本号**：V1.0  

---

## 一、软件基本信息

### 1.1 软件全称
紫微智能体治理基础设施平台 V1.0

### 1.2 软件简称
紫微平台

### 1.3 软件分类
- 一级分类：应用软件
- 二级分类：安全管理软件
- 三级分类：AI 智能体治理与审计系统

### 1.4 开发完成日期
2026年2月

### 1.5 首次发表日期
2026年2月

### 1.6 开发方式
独立开发

### 1.7 权利范围
全部权利

### 1.8 软件用途
为企业提供 AI 智能体的身份管理、权限控制、操作审计、合规存证等全生命周期治理能力，让企业可以安全、合规地使用 AI 智能体。

---

## 二、软件功能说明书

### 2.1 软件概述

紫微智能体治理基础设施平台是一个企业级的 AI 智能体安全合规治理系统，采用"联邦通信 + 区块链存证 + 策略引擎"的技术架构，为企业提供独立第三方的智能体治理能力。

**核心定位**：
- 智能体时代的安全合规基础设施
- 独立第三方治理层，不绑定任何智能体平台
- 提供司法级审计证据，满足强监管场景要求

**核心价值**：
- 让企业可以大胆放心地使用 AI 智能体
- 解决身份失管、操作失控、审计盲区三大问题

---

### 2.2 系统架构

紫微平台由三个核心子系统构成：

#### 2.2.1 天枢（Tianshu）- 智能体通信与身份底座

**功能**：
1. **区块链 DID 管理**
   - 为每个智能体分配唯一的去中心化标识符（DID）
   - 符合 W3C DID 标准
   - 支持 DID 注册、查询、验证、吊销

2. **环境指纹绑定**
   - 采集智能体运行环境的硬件特征、容器 ID、网络指纹
   - 将环境指纹与 DID 绑定，防止身份被冒充
   - 智能体启动时验证环境指纹，不一致则进入"待验证"状态

3. **Matrix 联邦通信**
   - 基于 Matrix 协议实现跨组织、跨平台的智能体通信
   - 支持端到端加密
   - 所有消息携带 DID 签名，接收方可验证身份

4. **企业 IM 适配**
   - 集成飞书、钉钉、企业微信等企业 IM
   - 将审批请求推送到 IM，支持一键审批
   - 支持生物识别（指纹、面容）审批

**技术栈**：
- 语言：Python 3.8+
- 通信协议：Matrix（matrix-nio）
- 身份标准：W3C DID
- 企业 IM：飞书 SDK、钉钉 SDK、企微 SDK

---

#### 2.2.2 獬豸（Xiezhi 3AF）- 智能体审计与防火墙

**功能**：
1. **动态 API 代理**
   - 拦截智能体的所有 HTTP/HTTPS 请求
   - 无需修改智能体代码（零侵入）
   - 支持任意 API 调用（OpenAI、GitHub、Stripe 等）

2. **风险评估**
   - 基于 HTTP 方法、URL 路径、请求体内容进行风险评分（0-100）
   - 三级风险分类：低风险、中风险、高风险
   - 支持自定义风险规则

3. **Cedar 策略引擎**
   - 基于属性的访问控制（ABAC）
   - 微秒级策略决策
   - 支持复杂的策略组合（AND、OR、NOT）

4. **分级审批流程**
   - 低风险：自动通过
   - 中风险：点击确认
   - 高风险：生物识别（指纹、面容）
   - 极高风险：直接拒绝

5. **全行为 Trace**
   - 记录智能体的所有操作（文件、命令、API、数据库）
   - 每条 Trace 生成 SHA3-256 哈希
   - 支持操作回放和审计查询

6. **Merkle 树批处理上链**
   - 将操作指纹打包成 Merkle 树
   - 定期将 Merkle 树根哈希写入区块链
   - 3 秒验真，司法级证据

**技术栈**：
- 语言：Go 1.21+
- 策略引擎：Cedar（AWS 开源）
- 区块链：Hyperledger Fabric / 长安链（可选）
- 性能：2000+ req/s

---

#### 2.2.3 太白（Taibai）- 智能体接入规范与 SDK

**功能**：
1. **统一接入 SDK**
   - 提供 Python、Go、Node.js、Java 等多语言 SDK
   - 5 行代码即可接入紫微
   - 自动处理 DID 注册、心跳、Trace 上报

2. **主流平台适配**
   - OpenClaw、Dify、金智维、实在智能等
   - 提供预置适配器，开箱即用
   - 支持自定义适配器

3. **接入验证智能体**
   - 提供验证智能体，用于集成测试
   - 自动测试发现、注册、心跳、Trace 上报等功能
   - 确保接入质量

**技术栈**：
- 语言：Python 3.8+
- 协议：太白协议（基于 Matrix 事件扩展）

---

### 2.3 核心功能列表

#### 功能模块 1：智能体身份管理

| 功能点 | 说明 |
|-------|------|
| DID 注册 | 为智能体分配唯一的去中心化标识符 |
| 环境指纹采集 | 采集硬件特征、容器 ID、网络指纹 |
| 环境指纹绑定 | 将环境指纹与 DID 绑定，防冒充 |
| 环境指纹验证 | 智能体启动时验证环境，不一致则降级 |
| DID 查询 | 根据 DID 查询智能体信息 |
| DID 吊销 | 吊销不可信的智能体 DID |
| 跨域身份验证 | 基于 Matrix 协议，跨组织验证身份 |

#### 功能模块 2：智能体操作拦截与审批

| 功能点 | 说明 |
|-------|------|
| API 调用拦截 | 拦截所有 HTTP/HTTPS 请求 |
| 文件操作拦截 | 拦截文件读写、删除、权限修改 |
| 命令执行拦截 | 拦截 shell 命令、脚本执行 |
| 数据库操作拦截 | 拦截 SQL 语句（SELECT、UPDATE、DELETE 等） |
| 风险评分 | 基于操作类型、路径、内容进行风险评分 |
| 策略匹配 | 基于 Cedar 策略引擎进行决策 |
| 飞书审批推送 | 将审批请求推送到飞书 |
| 钉钉审批推送 | 将审批请求推送到钉钉 |
| 企微审批推送 | 将审批请求推送到企业微信 |
| 生物识别审批 | 支持指纹、面容识别审批 |
| 审批超时处理 | 超时自动拒绝或降级 |

#### 功能模块 3：智能体行为审计与存证

| 功能点 | 说明 |
|-------|------|
| 全行为 Trace | 记录所有操作（文件、命令、API、数据库） |
| 操作指纹生成 | 为每条 Trace 生成 SHA3-256 哈希 |
| Merkle 树构建 | 将操作指纹打包成 Merkle 树 |
| 区块链上链 | 将 Merkle 树根哈希写入区块链 |
| 快速验真 | 3 秒验证记录是否被篡改 |
| 审计日志查询 | 支持按时间、智能体、操作类型查询 |
| 审计日志导出 | 导出为 CSV、JSON、PDF 格式 |
| 合规报告生成 | 生成符合监管要求的审计报告 |

#### 功能模块 4：跨平台统一治理

| 功能点 | 说明 |
|-------|------|
| 多平台接入 | 支持 OpenClaw、Dify、金智维等平台 |
| 统一策略配置 | 一套规则，管理所有平台的智能体 |
| 跨平台身份互信 | 基于 DID，跨平台验证身份 |
| 跨组织协作 | 基于 Matrix 联邦协议，跨组织互信 |

---

### 2.4 技术特点

#### 2.4.1 独立第三方治理层

- 不绑定任何智能体平台
- 可以横在多个平台之上
- 避免"既当运动员又当裁判员"

#### 2.4.2 区块链存证

- 操作指纹 Merkle 树批处理上链
- 任何人无法篡改（包括平台、企业、紫微自己）
- 3 秒验真，司法级证据

#### 2.4.3 联邦通信

- 基于 Matrix 协议
- 跨组织、跨平台的智能体可以互相验证身份
- 无需中心化网关

#### 2.4.4 操作系统级拦截

- 在操作系统级拦截危险操作
- 无论提示词怎么写，无论大模型怎么理解
- 危险操作都会被拦截

#### 2.4.5 高性能

- 獬豸基于 Go 语言，性能优异
- 支持 2000+ req/s
- 操作上报延迟 < 100ms

---

### 2.5 应用场景

#### 场景 1：金融机构

**需求**：
- 财务智能体自动转账
- 必须有审批记录和不可篡改的证据
- 满足监管要求

**紫微方案**：
- 智能体发起转账，獬豸拦截
- 飞书卡片推送给审批人
- 审批通过后，操作指纹上链
- 所有记录不可篡改，3 秒验真

#### 场景 2：政务机关

**需求**：
- 跨部门智能体协作
- 数据访问必须有授权
- 责任必须清晰

**紫微方案**：
- 每个智能体有 DID，绑定部门
- 跨部门访问时验证 DID
- 所有操作指纹上链
- 出问题了，链上存证明确责任

#### 场景 3：供应链企业

**需求**：
- 上下游智能体互相调用
- 不知道对方的智能体是否可信

**紫微方案**：
- 每个智能体有 DID，绑定企业
- 跨企业调用时验证 DID
- 基于 Matrix 联邦协议，无需中心化网关

---

## 三、软件技术文档

### 3.1 开发环境

**天枢**：
- 操作系统：Linux / macOS / Windows
- 开发语言：Python 3.8+
- 主要框架：matrix-nio、aiohttp、lark-oapi
- 数据库：PostgreSQL 13+
- 区块链：Hyperledger Fabric 2.x / 长安链

**獬豸**：
- 操作系统：Linux / macOS / Windows
- 开发语言：Go 1.21+
- 主要框架：Cedar、Gin、GORM
- 数据库：PostgreSQL 13+
- 区块链：Hyperledger Fabric 2.x / 长安链

**太白**：
- 操作系统：Linux / macOS / Windows
- 开发语言：Python 3.8+
- 主要框架：matrix-nio、aiohttp

### 3.2 运行环境

**最低配置**：
- CPU：4 核
- 内存：8 GB
- 存储：100 GB
- 网络：1 Gbps

**推荐配置**：
- CPU：8 核
- 内存：16 GB
- 存储：500 GB
- 网络：10 Gbps

**部署方式**：
- Docker / Kubernetes
- 支持私有化部署
- 支持信创环境（鲲鹏、麒麟、达梦等）

---

### 3.3 代码统计

| 子系统 | 语言 | 代码行数 | 文件数 |
|-------|------|---------|--------|
| 天枢 | Python | ~8,000 | ~50 |
| 獬豸 | Go | ~12,000 | ~80 |
| 太白 | Python | ~3,000 | ~20 |
| **总计** | - | **~23,000** | **~150** |

---

## 四、软件源代码（前 60 页）

### 说明
根据软著申请要求，需要提交源代码前 30 页和后 30 页，共 60 页。每页不少于 50 行。

以下为源代码示例（实际申请时需要提交完整的 60 页代码）：

### 4.1 天枢核心代码示例

```python
# tianshu/src/core/did_manager.py
# DID 管理模块

import hashlib
import json
from typing import Dict, Optional
from datetime import datetime

class DIDManager:
    """
    DID 管理器
    负责 DID 的注册、查询、验证、吊销
    """
    
    def __init__(self, blockchain_client, db_client):
        self.blockchain = blockchain_client
        self.db = db_client
    
    async def register_did(
        self,
        agent_id: str,
        public_key: str,
        environment_fingerprint: Dict
    ) -> str:
        """
        注册 DID
        
        Args:
            agent_id: 智能体 ID
            public_key: 公钥
            environment_fingerprint: 环境指纹
            
        Returns:
            DID 字符串
        """
        # 生成 DID
        did = self._generate_did(agent_id, public_key)
        
        # 构建 DID 文档
        did_document = {
            "id": did,
            "publicKey": [{
                "id": f"{did}#keys-1",
                "type": "Ed25519VerificationKey2018",
                "controller": did,
                "publicKeyBase58": public_key
            }],
            "authentication": [f"{did}#keys-1"],
            "created": datetime.utcnow().isoformat(),
            "environmentFingerprint": environment_fingerprint
        }
        
        # 上链
        tx_id = await self.blockchain.write_did_document(
            did, 
            did_document
        )
        
        # 存储到数据库
        await self.db.save_did_mapping(
            agent_id=agent_id,
            did=did,
            tx_id=tx_id,
            created_at=datetime.utcnow()
        )
        
        return did
    
    def _generate_did(self, agent_id: str, public_key: str) -> str:
        """
        生成 DID
        
        格式: did:ziwei:<hash>
        """
        data = f"{agent_id}:{public_key}".encode()
        hash_value = hashlib.sha256(data).hexdigest()[:32]
        return f"did:ziwei:{hash_value}"
    
    async def verify_environment(
        self,
        did: str,
        current_fingerprint: Dict
    ) -> bool:
        """
        验证环境指纹
        
        Args:
            did: DID 字符串
            current_fingerprint: 当前环境指纹
            
        Returns:
            是否匹配
        """
        # 从链上获取 DID 文档
        did_document = await self.blockchain.read_did_document(did)
        
        if not did_document:
            return False
        
        # 获取注册时的环境指纹
        registered_fingerprint = did_document.get("environmentFingerprint")
        
        # 比对关键字段
        return self._compare_fingerprints(
            registered_fingerprint,
            current_fingerprint
        )
    
    def _compare_fingerprints(
        self,
        registered: Dict,
        current: Dict
    ) -> bool:
        """
        比对环境指纹
        """
        # 硬件特征
        if registered.get("hardware") != current.get("hardware"):
            return False
        
        # 容器 ID
        if registered.get("container_id") != current.get("container_id"):
            return False
        
        # 网络指纹
        if registered.get("network") != current.get("network"):
            return False
        
        return True
```

### 4.2 獬豸核心代码示例

```go
// xiezhi/internal/core/interceptor.go
// API 拦截器

package core

import (
    "context"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "net/http"
    "time"
)

// Interceptor API 拦截器
type Interceptor struct {
    riskAssessor  *RiskAssessor
    policyEngine  *PolicyEngine
    approvalMgr   *ApprovalManager
    auditLogger   *AuditLogger
}

// InterceptRequest 拦截请求
func (i *Interceptor) InterceptRequest(
    ctx context.Context,
    req *http.Request,
    agentDID string,
) (*InterceptResult, error) {
    // 1. 风险评估
    riskScore, err := i.riskAssessor.Assess(req)
    if err != nil {
        return nil, fmt.Errorf("risk assessment failed: %w", err)
    }
    
    // 2. 策略决策
    decision, err := i.policyEngine.Evaluate(ctx, &PolicyRequest{
        AgentDID:  agentDID,
        Method:    req.Method,
        URL:       req.URL.String(),
        RiskScore: riskScore,
    })
    if err != nil {
        return nil, fmt.Errorf("policy evaluation failed: %w", err)
    }
    
    // 3. 根据决策处理
    switch decision.Action {
    case ActionAllow:
        // 自动通过
        return i.allowRequest(ctx, req, agentDID, riskScore)
        
    case ActionApprove:
        // 需要审批
        return i.requestApproval(ctx, req, agentDID, riskScore, decision)
        
    case ActionDeny:
        // 直接拒绝
        return i.denyRequest(ctx, req, agentDID, riskScore, decision.Reason)
        
    default:
        return nil, fmt.Errorf("unknown action: %s", decision.Action)
    }
}

// allowRequest 允许请求
func (i *Interceptor) allowRequest(
    ctx context.Context,
    req *http.Request,
    agentDID string,
    riskScore float64,
) (*InterceptResult, error) {
    // 生成操作指纹
    fingerprint := i.generateFingerprint(req, agentDID)
    
    // 记录审计日志
    trace := &AuditTrace{
        TraceID:     generateTraceID(),
        AgentDID:    agentDID,
        Method:      req.Method,
        URL:         req.URL.String(),
        RiskScore:   riskScore,
        Decision:    "allow",
        Fingerprint: fingerprint,
        Timestamp:   time.Now(),
    }
    
    if err := i.auditLogger.Log(ctx, trace); err != nil {
        return nil, fmt.Errorf("audit logging failed: %w", err)
    }
    
    return &InterceptResult{
        Allowed:     true,
        TraceID:     trace.TraceID,
        Fingerprint: fingerprint,
    }, nil
}

// requestApproval 请求审批
func (i *Interceptor) requestApproval(
    ctx context.Context,
    req *http.Request,
    agentDID string,
    riskScore float64,
    decision *PolicyDecision,
) (*InterceptResult, error) {
    // 生成操作指纹
    fingerprint := i.generateFingerprint(req, agentDID)
    
    // 创建审批请求
    approvalReq := &ApprovalRequest{
        AgentDID:    agentDID,
        Method:      req.Method,
        URL:         req.URL.String(),
        RiskScore:   riskScore,
        Fingerprint: fingerprint,
        ApprovalType: decision.ApprovalType, // click / biometric
        Approvers:   decision.Approvers,
        Timeout:     decision.Timeout,
    }
    
    // 推送到飞书/钉钉/企微
    approvalID, err := i.approvalMgr.Request(ctx, approvalReq)
    if err != nil {
        return nil, fmt.Errorf("approval request failed: %w", err)
    }
    
    // 等待审批结果
    result, err := i.approvalMgr.Wait(ctx, approvalID)
    if err != nil {
        return nil, fmt.Errorf("approval wait failed: %w", err)
    }
    
    // 记录审计日志
    trace := &AuditTrace{
        TraceID:     generateTraceID(),
        AgentDID:    agentDID,
        Method:      req.Method,
        URL:         req.URL.String(),
        RiskScore:   riskScore,
        Decision:    result.Decision, // approved / rejected
        ApprovalID:  approvalID,
        Approver:    result.Approver,
        Fingerprint: fingerprint,
        Timestamp:   time.Now(),
    }
    
    if err := i.auditLogger.Log(ctx, trace); err != nil {
        return nil, fmt.Errorf("audit logging failed: %w", err)
    }
    
    return &InterceptResult{
        Allowed:     result.Decision == "approved",
        TraceID:     trace.TraceID,
        Fingerprint: fingerprint,
        ApprovalID:  approvalID,
    }, nil
}

// generateFingerprint 生成操作指纹
func (i *Interceptor) generateFingerprint(
    req *http.Request,
    agentDID string,
) string {
    data := fmt.Sprintf(
        "%s:%s:%s:%d",
        agentDID,
        req.Method,
        req.URL.String(),
        time.Now().Unix(),
    )
    
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

**（实际申请时需要提交完整的 60 页代码，此处仅为示例）**

---

## 五、软件界面截图

### 5.1 智能体管理界面
[待补充截图]

### 5.2 策略配置界面
[待补充截图]

### 5.3 审计日志查询界面
[待补充截图]

### 5.4 飞书审批卡片
[待补充截图]

---

## 六、核心模块详细说明

### 6.1 天枢模块（Tianshu）- 智能体通信与身份底座

#### 6.1.1 核心功能

**1. DID 注册与管理**
- 为每个智能体分配唯一的去中心化标识符（格式：`did:ziwei:<hash>`）
- 符合 W3C DID 标准规范
- 支持 DID 的注册、查询、验证、吊销全生命周期管理

**2. 环境指纹采集与绑定**
- 采集智能体运行环境的多维度特征：
  - 硬件特征：CPU 型号、序列号、内存信息
  - 容器特征：容器 ID、镜像 ID、网络模式
  - 网络特征：IP 地址、MAC 地址、DNS 配置
  - 软件特征：操作系统版本、运行时版本
- 将环境指纹与 DID 绑定，生成 SHA256 哈希存储

**3. 环境指纹验证**
- 智能体每次启动时自动验证环境指纹
- 指纹匹配：保持"正常"状态
- 指纹失配：触发"待验证"状态，需人工审批

**4. Matrix 联邦通信**
- 基于 Matrix 协议实现跨组织通信
- 消息携带 DID 签名，接收方实时验真
- 支持端到端加密

**5. 企业 IM 适配**
- 支持飞书、钉钉、企业微信
- 审批卡片推送，一键审批
- 支持生物识别审批

#### 6.1.2 核心代码结构

```
tianshu/
├── src/
│   ├── core/
│   │   ├── did_manager.py      # DID 管理
│   │   ├── fingerprint.py      # 环境指纹
│   │   ├── verifier.py         # 指纹验证
│   │   └── state_machine.py    # 状态机
│   ├── matrix/
│   │   ├── client.py           # Matrix 客户端
│   │   ├── signer.py           # 消息签名
│   │   └── verifier.py         # 消息验真
│   ├── im/
│   │   ├── feishu.py           # 飞书集成
│   │   ├── dingtalk.py         # 钉钉集成
│   │   └── wecom.py            # 企微集成
│   └── api/
│       └── routes.py            # API 路由
└── tests/
```

### 6.2 獬豸模块（Xiezhi 3AF）- 智能体审计与防火墙

#### 6.2.1 核心功能

**1. 动态 API 代理**
- HTTP/HTTPS 请求拦截，无需修改智能体代码
- 支持任意目标 API（OpenAI、GitHub、Stripe 等）
- 零侵入部署

**2. 多维度风险评估**
- HTTP 方法风险评分
- URL 路径危险关键词检测
- 请求体内容分析
- 目标域名白名单

**3. Cedar 策略引擎**
- 基于属性的访问控制（ABAC）
- 微秒级策略决策
- 支持复杂策略组合

**4. 分级审批**
| 风险等级 | 处理方式 |
|---------|---------|
| 低风险 | 自动通过 |
| 中风险 | 记录日志，自动通过 |
| 高风险 | 人工审批 |
| 极高风险 | 直接拒绝 |

**5. 全行为 Trace**
- 记录所有操作（API、文件、命令、数据库）
- 生成 SHA3-256 操作指纹

**6. Merkle 树审计存证**
- N 条指纹打包成批次
- 构建 Merkle 树，计算根哈希
- 根哈希写入区块链
- 3 秒快速验真

#### 6.2.2 核心代码结构

```
xiezhi/
├── internal/
│   ├── core/
│   │   ├── interceptor.go     # 请求拦截
│   │   ├── risk_assessor.go   # 风险评估
│   │   ├── policy_engine.go   # 策略引擎
│   │   └── approval_mgr.go    # 审批管理
│   ├── audit/
│   │   ├── trace.go           # Trace 生成
│   │   ├── fingerprint.go     # 指纹生成
│   │   ├── merkle.go          # Merkle 树
│   │   └── logger.go          # 审计日志
│   ├── blockchain/
│   │   └── client.go          # 区块链客户端
│   └── delivery/
│       ├── feishu.go          # 飞书推送
│       ├── dingtalk.go        # 钉钉推送
│       └── wecom.go           # 企微推送
└── cmd/
    └── xiezhi/
        └── main.go
```

### 6.3 太白模块（Taibai）- 智能体接入规范与 SDK

#### 6.3.1 核心功能

**1. 多语言 SDK**
- Python、Go、Node.js、Java
- 5 行代码快速接入

**2. 主流平台适配**
- OpenClaw、Dify、金智维、实在智能
- 预置适配器，开箱即用

**3. 验证智能体**
- 自动测试接入功能
- DID 注册、心跳、Trace 上报

#### 6.3.2 核心代码结构

```
taibai/
├── sdk/
│   ├── python/
│   │   ├── __init__.py
│   │   ├── client.py
│   │   ├── did.py
│   │   └── trace.py
│   ├── go/
│   ├── nodejs/
│   └── java/
├── adapters/
│   ├── openclaw.py
│   ├── dify.py
│   └── jinzhikwei.py
└── examples/
```

---

## 七、申请材料清单

### 6.1 必需材料

1. ✅ 软件著作权登记申请表
2. ✅ 软件功能说明书（本文档第二部分）
3. ✅ 源代码前 30 页 + 后 30 页（本文档第四部分）
4. ⏳ 申请人身份证明（营业执照副本复印件）
5. ⏳ 申请人签章

### 6.2 可选材料

1. ⏳ 软件界面截图
2. ⏳ 软件使用手册
3. ⏳ 软件测试报告

---

## 七、注意事项

### 7.1 软件名称

- 全称：紫微智能体治理基础设施平台 V1.0
- 简称：紫微平台
- 英文名称：Ziwei AI Agent Governance Platform

### 7.2 版本号

- 当前版本：V1.0
- 版本日期：2026年2月

### 7.3 权利归属

- 权利范围：全部权利
- 开发方式：独立开发
- 权利取得方式：原始取得

### 7.4 代码要求

- 前 30 页 + 后 30 页，共 60 页
- 每页不少于 50 行
- 需要包含关键功能代码
- 需要有注释说明

---

## 八、后续工作

### 8.1 立即行动

1. ✅ 准备申请表
2. ✅ 整理源代码（前 30 页 + 后 30 页）
3. ⏳ 准备营业执照复印件
4. ⏳ 准备软件界面截图

### 8.2 提交流程

1. 在线填写申请表
2. 上传申请材料
3. 缴纳申请费用
4. 等待审查（约 30-60 个工作日）
5. 领取证书

---

**文档结束**
